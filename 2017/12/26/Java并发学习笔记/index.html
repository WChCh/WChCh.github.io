<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="woaiwchch@126.com"><title>Java并发学习笔记 | WChCh's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java并发学习笔记</h1><a id="logo" href="/.">WChCh's Blog</a><p class="description">Coding My Life</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java并发学习笔记</h1><div class="post-meta">Dec 26, 2017<span> | </span><span class="category"><a href="/categories/技术/">技术</a><a href="/categories/技术/学习/">学习</a><a href="/categories/技术/学习/Java/">Java</a><a href="/categories/技术/学习/Java/并发/">并发</a></span></div><div class="post-content"><h4 id="并发基础"><a href="#并发基础" class="headerlink" title="并发基础"></a>并发基础</h4><h5 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h5><ol>
<li>对某个对象加锁</li>
<li>当修饰静态方法或是代码块时，表示对Class对象加锁。</li>
<li>同步和非同步方法可以同时调用。</li>
<li>一般情况下要对读方法和写方法同时加锁，要不很可能会出现脏读问题。</li>
<li>一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁，synchronized获得的锁是可重入的。</li>
<li>程序在执行过程中，如果出现异常，默认情况锁会被释放。</li>
<li>同步代码块中的语句越少越好。</li>
<li>锁定某对象o，如果o的属性发生改变，不影响锁的使用，但是如果o变成另外一个对象，则锁定的对象发生改变，应该避免将锁定对象的引用变成另外的对象。</li>
<li>不要以字符串常量作为锁定对象，因为你的程序和你用到的类库不经意间使用了同一把锁，比如相同的字符串常量。</li>
</ol>
<h5 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h5><p>volatile只能保证可见性，但是不保证原子性。</p>
<ol>
<li>volatile并不能保证多个线程共同修改同一变量时所带来的不一致问题，也就是说volatile不能替代synchronized。</li>
<li>nchronized可以保证可见性和原子性，volatile只能保证可见性。</li>
</ol>
<h5 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h5><p>使用原子方式更新基本类型，共包括3个类：</p>
<ul>
<li>AtomicBoolean：原子更新布尔变量</li>
<li>AtomicInteger：原子更新整型变量</li>
<li>AtomicLong：原子更新长整型变量</li>
</ul>
<p>解决同样的问题的更高效的方法，使用AtomXXX类，AtomXXX类本身方法都是原子性的，但不能保证多个方法连续调用是原子性的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/*volatile*/ //int count = 0;</div><div class="line"></div><div class="line">AtomicInteger count = new AtomicInteger(0); </div><div class="line"></div><div class="line">/*synchronized*/ void m() &#123; </div><div class="line">for (int i = 0; i &lt; 10000; i++)</div><div class="line">	//if count.get() &lt; 1000</div><div class="line">	count.incrementAndGet(); //count++</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">	T t = new T();</div><div class="line"></div><div class="line">	List&lt;Thread&gt; threads = new ArrayList&lt;Thread&gt;();</div><div class="line"></div><div class="line">for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">	threads.add(new Thread(t::m, &quot;thread-&quot; + i));</div><div class="line">&#125;</div><div class="line"></div><div class="line">threads.forEach((o) -&gt; o.start());</div><div class="line"></div><div class="line">threads.forEach((o) -&gt; &#123;</div><div class="line">	try &#123;</div><div class="line">		o.join();</div><div class="line">	&#125; catch (InterruptedException e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">System.out.println(t.count);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>ThreadLocal线程局部变量，是使用空间换时间，synchronized是使用时间换空间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//volatile static Person p = new Person();</div><div class="line">static ThreadLocal&lt;Person&gt; tl = new ThreadLocal&lt;&gt;();</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">			</div><div class="line">new Thread(()-&gt;&#123;</div><div class="line">	try &#123;</div><div class="line">		TimeUnit.SECONDS.sleep(2);</div><div class="line">	&#125; catch (InterruptedException e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">	&#125;</div><div class="line">	tl.set(new Person());</div><div class="line">	System.out.println(tl.get().name);</div><div class="line">&#125;).start();</div><div class="line"></div><div class="line">new Thread(()-&gt;&#123;</div><div class="line">	try &#123;</div><div class="line">		TimeUnit.SECONDS.sleep(1);</div><div class="line">	&#125; catch (InterruptedException e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">	&#125;</div><div class="line">	tl.set(new Person());</div><div class="line">	System.out.println(tl.get());</div><div class="line">&#125;).start(); </div><div class="line">&#125;</div><div class="line"></div><div class="line">static class Person &#123;</div><div class="line">	String name = &quot;zhangsan&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Java中的锁"><a href="#Java中的锁" class="headerlink" title="Java中的锁"></a>Java中的锁</h4><h5 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h5><p>锁能够防止多个线程同时访问共享资源。Lock接口在使用时需要显示地获取和释放锁（Synchronized是隐式的），并且是可中断、可超时获取等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ReentrantLock1 rl = new ReentrantLock1();</div><div class="line">Lock1 r2 = new ReentrantLock1();</div></pre></td></tr></table></figure></p>
<h5 id="队列同步器AbstractQueuedSynchronizer-AQS"><a href="#队列同步器AbstractQueuedSynchronizer-AQS" class="headerlink" title="队列同步器AbstractQueuedSynchronizer(AQS)"></a>队列同步器AbstractQueuedSynchronizer(AQS)</h5><p>队列同步器AbstractQueuedSynchronizer(AQS)，似乎我们不经常用，但是它是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。</p>
<h5 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h5><p>推荐使用reentrantlock用于替代synchronized。</p>
<ol>
<li><p>需要注意的是，必须要必须要必须要手动释放锁。使用syn锁定的话如果遇到异常，jvm会自动释放锁，但是lock必须手动释放锁，因此经常在finally中进行锁的释放。示例：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">	lock.lock(); //synchronized(this)</div><div class="line">	for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">		TimeUnit.SECONDS.sleep(1);</div><div class="line"></div><div class="line">		System.out.println(i);</div><div class="line">		&#125;</div><div class="line">	&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">	&#125; finally &#123;</div><div class="line">	   lock.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>使用reentrantlock可以进行“尝试锁定”tryLock，这样无法锁定，或者在指定时间内无法锁定，线程可以决定是否继续等待。可以根据tryLock的返回值来判定是否锁定，也可以指定tryLock的时间，由于tryLock(time)抛出异常，所以要注意unclock的处理，必须放到finally中</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> boolean locked = false;</div><div class="line">		</div><div class="line">try &#123;</div><div class="line">	locked = lock.tryLock(5, TimeUnit.SECONDS);</div><div class="line">	System.out.println(&quot;m2 ...&quot; + locked);</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">	e.printStackTrace();</div><div class="line">&#125; finally &#123;</div><div class="line">	if(locked) lock.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>使用ReentrantLock还可以调用lockInterruptibly方法，可以对线程interrupt方法做出响应，实现一个线程在等待锁的过程中，可以被打断。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Thread t2 = new Thread(()-&gt;&#123;</div><div class="line">try &#123;</div><div class="line">	//lock.lock();</div><div class="line">	lock.lockInterruptibly(); //可以对interrupt()方法做出响应</div><div class="line">	System.out.println(&quot;t2 start&quot;);</div><div class="line">	TimeUnit.SECONDS.sleep(5);</div><div class="line">	System.out.println(&quot;t2 end&quot;);</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">	System.out.println(&quot;interrupted!&quot;);</div><div class="line">&#125; finally &#123;</div><div class="line">	lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">t2.start();</div><div class="line"></div><div class="line">try &#123;</div><div class="line">	TimeUnit.SECONDS.sleep(1);</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">	e.printStackTrace();</div><div class="line">&#125;</div><div class="line">t2.interrupt(); //打断线程2的等待</div></pre></td></tr></table></figure>
</li>
<li><p>ReentrantLock还可以指定为公平锁</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">private static ReentrantLock lock=new ReentrantLock(true); //参数为true表示为公平锁，请对比输出结果</div><div class="line">public void run() &#123;</div><div class="line">    for(int i=0; i&lt;100; i++) &#123;</div><div class="line">        lock.lock();</div><div class="line">        try&#123;</div><div class="line">            System.out.println(Thread.currentThread().getName()+&quot;获得锁&quot;);</div><div class="line">        &#125;finally&#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">    ReentrantLock5 rl=new ReentrantLock5();</div><div class="line">    Thread th1=new Thread(rl);</div><div class="line">    Thread th2=new Thread(rl);</div><div class="line">    th1.start();</div><div class="line">    th2.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><p>读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过读写分离，使得并发性相比一般的排他性锁有了很大提升。读写锁的接口为<code>ReadWriteLock</code>，其实现为<code>ReentrantReadWriteLock</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ReentrantReadWriteLock rw = new ReentrantReadWriteLock();</div><div class="line">static Lock r = rw.readLock();</div><div class="line">static Lock w = rw.writeLock();</div></pre></td></tr></table></figure></p>
<h5 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h5><p>使用Lock和Condition来实现，对比使用wait和notify/notifyAll，Condition的方式可以更加精确的指定哪些线程被唤醒。并且要像wait()使用一个while循环来做限制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">	final private LinkedList&lt;T&gt; lists = new LinkedList&lt;&gt;();</div><div class="line">final private int MAX = 10; //最多10个元素</div><div class="line">private int count = 0;</div><div class="line"></div><div class="line">private Lock lock = new ReentrantLock();</div><div class="line">private Condition producer = lock.newCondition();</div><div class="line">private Condition consumer = lock.newCondition();</div><div class="line"></div><div class="line">public void put(T t) &#123;</div><div class="line">    try &#123;</div><div class="line">    	lock.lock();</div><div class="line">    	while(lists.size() == MAX) &#123; //想想为什么用while而不是用if？</div><div class="line">    		producer.await();</div><div class="line">    	&#125;</div><div class="line">    	</div><div class="line">    	lists.add(t);</div><div class="line">    	++count;</div><div class="line">    	consumer.signalAll(); //通知消费者线程进行消费</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">    	e.printStackTrace();</div><div class="line">    &#125; finally &#123;</div><div class="line">    	lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public T get() &#123;</div><div class="line">	T t = null;</div><div class="line">    try &#123;</div><div class="line">    	lock.lock();</div><div class="line">    	while(lists.size() == 0) &#123;</div><div class="line">    		consumer.await();</div><div class="line">    	&#125;</div><div class="line">    	t = lists.removeFirst();</div><div class="line">    	count --;</div><div class="line">    	producer.signalAll(); //通知生产者进行生产</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">    	e.printStackTrace();</div><div class="line">    &#125; finally &#123;</div><div class="line">    	lock.unlock();</div><div class="line">    &#125;</div><div class="line">	return t;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">	MyContainer2&lt;String&gt; c = new MyContainer2&lt;&gt;();</div><div class="line">	//启动消费者线程</div><div class="line">    for(int i=0; i&lt;10; i++) &#123;</div><div class="line">    	new Thread(()-&gt;&#123;</div><div class="line">    		for(int j=0; j&lt;5; j++) System.out.println(c.get());</div><div class="line">    	&#125;, &quot;c&quot; + i).start();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    try &#123;</div><div class="line">    	TimeUnit.SECONDS.sleep(2);</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">    	e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //启动生产者线程</div><div class="line">    for(int i=0; i&lt;2; i++) &#123;</div><div class="line">    	new Thread(()-&gt;&#123;</div><div class="line">    		for(int j=0; j&lt;25; j++) c.put(Thread.currentThread().getName() + &quot; &quot; + j);</div><div class="line">    	&#125;, &quot;p&quot; + i).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h4><p>使用并发容器代替加锁的非并发容器。</p>
<h5 id="几种key-value容器的使用场景："><a href="#几种key-value容器的使用场景：" class="headerlink" title="几种key-value容器的使用场景："></a>几种key-value容器的使用场景：</h5><ol>
<li>快速存取<key, value="">键值对时可以使用HashMap。</key,></li>
<li>多线程并发中存取<key, value="">键值对时，可以选择ConcurrentHashMap。ConcurrentHashMa使用分段锁的技术。效率比HashTable效率高。</key,></li>
<li>当需要存取的键值对有序时可以使用TreeMap。TreeMap保证数据是按照Key的自然顺序或者compareTo方法指定的排序规则进行排序。底层是红黑树实现。</li>
<li>当需要多线程并发存取<key, value="">数据并且希望保证数据有序时，可以添加lock来实现ConcurrentTreeMap，但是随着并发量的提升，lock带来的性能开销也随之增大。此时可以选择ConcurrentSkipListMap提供了一种线程安全的并发访问的排序映射表。内部是SkipList（跳表）结构实现，在理论上能够O(log(n))时间内完成查找、插入、删除操作。</key,></li>
</ol>
<h5 id="写时复制容器CopyOnWriteArrayList"><a href="#写时复制容器CopyOnWriteArrayList" class="headerlink" title="写时复制容器CopyOnWriteArrayList"></a>写时复制容器CopyOnWriteArrayList</h5><p>多线程环境下，写时效率低，读时效率高，适合写少读多的环境。</p>
<h5 id="Collections-synchronizedList-方法"><a href="#Collections-synchronizedList-方法" class="headerlink" title="Collections.synchronizedList()方法"></a>Collections.synchronizedList()方法</h5><p>可以对某一个对象的方法加锁，但肯定效率也不高。如果Synchronized加锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; strs = new ArrayList&lt;&gt;();</div><div class="line">List&lt;String&gt; strsSync = Collections.synchronizedList(strs);</div></pre></td></tr></table></figure></p>
<h5 id="并发单向队列ConcurrentLinkedQueue"><a href="#并发单向队列ConcurrentLinkedQueue" class="headerlink" title="并发单向队列ConcurrentLinkedQueue"></a>并发单向队列ConcurrentLinkedQueue</h5><ol>
<li>提供有返回值的offer()方法，可判断是否添加成功。如果使用add()，如果添加未成功则抛出异常。</li>
<li>poll()方法表示拿出第一个。peek()也是拿出第一个，但是不删除。</li>
<li>底层是单向链表实现的无界队列。</li>
</ol>
<h5 id="并发双端队列ConcurrentLinkedDeque"><a href="#并发双端队列ConcurrentLinkedDeque" class="headerlink" title="并发双端队列ConcurrentLinkedDeque"></a>并发双端队列ConcurrentLinkedDeque</h5><ol>
<li>底层是双向列表实现，属于无界队列。</li>
</ol>
<h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h5><ol>
<li><p>阻塞式队列，链表实现。使用方法</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static BlockingQueue&lt;String&gt; strs = new LinkedBlockingQueue&lt;&gt;();</div><div class="line"></div><div class="line">strs.put(&quot;a&quot; + i); //如果满了，就会等待</div><div class="line"></div><div class="line">strs.take()); //如果空了，就会等待</div></pre></td></tr></table></figure>
</li>
<li><p>属于无界队列</p>
</li>
</ol>
<h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h5><ol>
<li>属于有界队列，代码如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static BlockingQueue&lt;String&gt; strs = new ArrayBlockingQueue&lt;&gt;(10);</div><div class="line"></div><div class="line">strs.put(&quot;aaa&quot;); //满了就会等待，程序阻塞</div><div class="line">//strs.add(&quot;aaa&quot;);</div><div class="line">//strs.offer(&quot;aaa&quot;);</div><div class="line">//strs.offer(&quot;aaa&quot;, 1,TimeUnit.SECONDS);//1秒钟之内加不进去就不加了</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h5><ol>
<li>属于无界队列。是有序的，等待时间最长的排在前面。</li>
<li>是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期时间最长。注意：不能将null元素放置到这种队列中。</li>
</ol>
<h5 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h5><ol>
<li>如果有消费者线程，那么直接将消息送给消费者线程，而不是放在队列里面。</li>
<li><p>如果没有消费者，使用的是<code>transfer()</code>方法，那么将阻塞在如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">strs.transfer(&quot;aaa&quot;);</div></pre></td></tr></table></figure>
<p>如果使用的是<code>add()，put()</code>方法则将加入到队列中。</p>
</li>
<li>队列为无界队列。</li>
</ol>
<h5 id="没有容量的队列SynchronousQueue"><a href="#没有容量的队列SynchronousQueue" class="headerlink" title="没有容量的队列SynchronousQueue"></a>没有容量的队列SynchronousQueue</h5><p>SynchronousQueue是容量为0的队列，消费者必须马上消费掉，否则出现问题。使用<code>add()</code>方法直接抛出异常，可以使用<code>put（）</code>将会阻塞。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">1：对于map/set的选择使用</div><div class="line"></div><div class="line">不需要并发：</div><div class="line">    HashMap</div><div class="line">    TreeMap</div><div class="line">    LinkedHashMap</div><div class="line"></div><div class="line">并发量小：</div><div class="line">    Hashtable</div><div class="line">    Collections.sychronizedXXX</div><div class="line"></div><div class="line">并发量大：</div><div class="line">    ConcurrentHashMap </div><div class="line">并发量大且排序：</div><div class="line">ConcurrentSkipListMap </div><div class="line"></div><div class="line">2：队列</div><div class="line"></div><div class="line">无需并发</div><div class="line">    ArrayList</div><div class="line">    LinkedList</div><div class="line">并发量小：</div><div class="line">    Collections.synchronizedXXX</div><div class="line">    Vector</div><div class="line"></div><div class="line">并发量大</div><div class="line">    写少，读多：</div><div class="line">        CopyOnWriteList</div><div class="line">    Queue</div><div class="line">    	CocurrentLinkedQueue //concurrentArrayQueue</div><div class="line">    	ConcurrentLinkedDeque</div><div class="line">    	BlockingQueue</div><div class="line">    		LinkedBlockingQueue</div><div class="line">    		ArrayBlockingQueue //有界</div><div class="line">    		TransferQueue //可以直接传递给消费者，但会阻塞</div><div class="line">    		SynchronusQueue //容量为0</div><div class="line">    	DelayQueue //执行定时任务，是有序的</div></pre></td></tr></table></figure>
<h4 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h4><p>常用的并发工具类有<code>CountDownLatch</code>，<code>CyclicBarrier</code>，<code>Semaphore</code>。用于并发流程控制。</p>
<p>使用Latch（门闩）替代wait notify来进行通知（不需要加锁时，如果是加锁，可能得需要Condition）:</p>
<ul>
<li>好处是通信方式简单，同时也可以指定等待时间</li>
<li>使用await和countdown方法替代wait和notify</li>
<li>CountDownLatch不涉及锁定，当count的值为零时当前线程继续运行</li>
<li>当不涉及同步，只是涉及线程通信的时候，用synchronized + wait/notify就显得太重了</li>
<li>这时应该考虑countdownlatch/cyclicbarrier/semaphore</li>
</ul>
<p>区别如下(<a href="http://blog.csdn.net/jackyechina/article/details/52931453" target="_blank" rel="external">转载地址</a>)：</p>
<ol>
<li>CountDownLatch 使一个线程A或是组线程A等待其它线程执行完毕后，一个线程A或是组线程A才继续执行。CyclicBarrier：一组线程使用await()指定barrier，所有线程都到达各自的barrier后，再同时执行各自barrier下面的代码。Semaphore：是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</li>
<li>CountDownLatch是减计数方式，计数==0时释放所有等待的线程；CyclicBarrier是加计数方式，计数达到构造方法中参数指定的值时释放所有等待的线程。Semaphore，每次semaphore.acquire()，获取一个资源，每次semaphore.acquire(n)，获取n个资源，当达到semaphore 指定资源数量时就不能再访问线程处于阻塞，必须等其它线程释放资源，semaphore.relase()每次资源一个资源，semaphore.relase(n)每次资源n个资源。</li>
<li>CountDownLatch当计数到0时，计数无法被重置；CyclicBarrier计数达到指定值时，计数置为0重新开始。</li>
<li>CountDownLatch每次调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响；CyclicBarrier只有一个await()方法，调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞。CyclicBarrier的计数器计数器可以使用reset()方法重置。例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。</li>
<li>CountDownLatch、CyclikBarrier、Semaphore 都有一个int类型参数的构造方法。CountDownLatch、CyclikBarrier这个值作为计数用，达到该次数即释放等待的线程，而Semaphore 中所有acquire获取到的资源达到这个数，会使得其它线程阻塞。</li>
</ol>
<p>应用场景：</p>
<ol>
<li>由于CountDownLatch有个countDown()方法并且countDown()不会引起阻塞，所以CountDownLatch可以应用于主线程等待所有子线程结束后再继续执行的情况。<code>await()</code>方法应用于主线程中。</li>
<li>由于CyclicBarrier计数达到指定后会重新循环使用，所以CyclicBarrier可以用在所有子线程之间互相等待多次的情形，作用是让所有线程到达一个屏障是被阻塞，直到最后一个线程到达屏障时，屏障才会开门。比如在某种需求中，比如一个大型的任务，常常需要分配好多子任务去执行，只有当所有子任务都执行完成时候，才能执行主任务，这时候，就可以选择CyclicBarrier了。<code>await()</code>方法应用于子线程中，告诉已经到达屏障。</li>
<li>Semaphore可以用于做流量控制，特别公用资源有限的应用场景，比如数据库连接。示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class SemaphoreCase &#123;  </div><div class="line">  </div><div class="line">    private static final int THREAD_COUNT = 30;  </div><div class="line">    private static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);  </div><div class="line">    private static Semaphore s = new Semaphore(10);  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        for (int i = 0; i &lt; THREAD_COUNT; i++) &#123;  </div><div class="line">            threadPool.execute(new Runnable() &#123;  </div><div class="line">                @Override  </div><div class="line">                public void run() &#123;  </div><div class="line">                    try &#123;  </div><div class="line">                        s.acquire();  </div><div class="line">                        System.out.println(&quot;save data&quot;);  </div><div class="line">                        s.release();  </div><div class="line">                    &#125; catch (InterruptedException e) &#123;  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">            &#125;);  </div><div class="line">        &#125;  </div><div class="line">        threadPool.shutdown();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>注意：</p>
<ol>
<li>release函数和acquire并没有要求一定是同一个线程都调用，可以A线程申请资源，B线程释放资源；</li>
<li>调用release函数之前并没有要求一定要先调用acquire函数。</li>
</ol>
<h5 id="线程间交换数据Exchanger"><a href="#线程间交换数据Exchanger" class="headerlink" title="线程间交换数据Exchanger"></a>线程间交换数据Exchanger</h5><p><code>Exchanger</code>用于进行线程间的数据交换。它提供一个同步点，在这个同步点两个线程可以交换彼此的数据。</p>
<h4 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h4><h5 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h5><ol>
<li>Executor是一个接口，它是Executor框架的基础。</li>
<li>ThreadPoolExecutor是线程池的核心实现类。</li>
<li>ScheduledThreadPoolExecutor是一个实现类，可以在给定的延迟后运行命令，或是定期执行命令。</li>
<li>Future接口和实现Future接口的FutureTask类，代表异步计算的结果。</li>
<li>Runnable接口和Callable接口的实现类，都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。</li>
</ol>
<p>ThreadPoolExecutor通常使用工厂类Executors来创建，可以创建3种ThreadPoolExecutor：</p>
<ol>
<li><p>FixedThreadPool.//固定线程数</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</div><div class="line">    return new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>SingleThreadExecutor.//固定一个线程。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newSingleThreadExecutor() &#123;</div><div class="line">    return new FinalizableDelegatedExecutorService</div><div class="line">        (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>CachedThreadPool.//弹性线程数，空闲线程存活时间默认为60s</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newCachedThreadPool() &#123;</div><div class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</div><div class="line">                                  60L, TimeUnit.SECONDS,</div><div class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>Executors可以创建2种类型的ScheduledThreadPoolExecutor：</p>
<ol>
<li><p>ScheduledThreadPoolExecutor.//默认等待时间最长的先运行</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</div><div class="line">    return new ScheduledThreadPoolExecutor(corePoolSize);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</div><div class="line">    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</div><div class="line">          new DelayedWorkQueue());</div><div class="line">&#125;</div><div class="line"></div><div class="line">public ThreadPoolExecutor(int corePoolSize,</div><div class="line">                          int maximumPoolSize,</div><div class="line">                          long keepAliveTime,</div><div class="line">                          TimeUnit unit,</div><div class="line">                          BlockingQueue&lt;Runnable&gt; workQueue) &#123;</div><div class="line">    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</div><div class="line">         Executors.defaultThreadFactory(), defaultHandler);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>SingleThreadScheduledExecutor.</p>
</li>
</ol>
<h5 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h5><p>ExecutorService是一个接口，继承了Executor，提供了submit()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ExecutorService service = Executors.newFixedThreadPool(5);</div><div class="line">service.shutdown();//所有线程跑完才关闭</div><div class="line">service.isShutdown();//马上关闭，不管跑没跑完</div><div class="line">service.isTerminated()；//所有的线程是否都已经执行完了</div><div class="line">service.isShutdown()；//线程池是否已经关闭。任务完成才关闭。</div></pre></td></tr></table></figure></p>
<h5 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h5><p>Executors是一个工具类。</p>
<h5 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h5><p>FutureTask实现Future接口和Runnable接口，可以得到一个线程返回值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(()-&gt;&#123;</div><div class="line">    TimeUnit.MILLISECONDS.sleep(500);</div><div class="line">    return 1000;</div><div class="line">&#125;); //new Callable () &#123; Integer call();&#125;</div><div class="line"></div><div class="line">new Thread(task).start();</div><div class="line"></div><div class="line">System.out.println(task.get()); //阻塞</div></pre></td></tr></table></figure></p>
<h5 id="WorkStealingPool"><a href="#WorkStealingPool" class="headerlink" title="WorkStealingPool"></a>WorkStealingPool</h5><p>WorkStealingPool会主动地拉取任务。会根据CPU的核数产生一样的线程数。WorkStealingPool的线程是daemon线程。是通过new ForkJoinPool来实现的，是对ForkJoinPool进行了封装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class T11_WorkStealingPool &#123;</div><div class="line">	public static void main(String[] args) throws IOException &#123;</div><div class="line">		ExecutorService service = Executors.newWorkStealingPool();</div><div class="line">		System.out.println(Runtime.getRuntime().availableProcessors());</div><div class="line"></div><div class="line">		service.execute(new R(1000));</div><div class="line">		service.execute(new R(2000));</div><div class="line">		service.execute(new R(2000));</div><div class="line">		service.execute(new R(2000)); //daemon</div><div class="line">		service.execute(new R(2000));</div><div class="line">		</div><div class="line">		//由于产生的是精灵线程（守护线程、后台线程），主线程不阻塞的话，看不到输出</div><div class="line">		System.in.read(); </div><div class="line">	&#125;</div><div class="line"></div><div class="line">	static class R implements Runnable &#123;</div><div class="line"></div><div class="line">		int time;</div><div class="line"></div><div class="line">		R(int t) &#123;</div><div class="line">			this.time = t;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public void run() &#123;</div><div class="line">			</div><div class="line">			try &#123;</div><div class="line">				TimeUnit.MILLISECONDS.sleep(time);</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			System.out.println(time  + &quot; &quot; + Thread.currentThread().getName());</div><div class="line">			</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h5><p>一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。ForkJoinPool的线程是精灵线程。</p>
<p>如果任务执行类继承的是RecursiveAction，那么没有返回值，如果是RecursiveTask则可以返回结果用于汇总。</p>
</div><div class="tags"><a href="/tags/Java/">Java</a><a href="/tags/并发/">并发</a></div><div class="post-nav"><a href="/2017/12/28/CAS-Compare-and-Swap-原理学习/" class="pre">CAS(Compare and Swap) 原理学习</a><a href="/2017/11/27/记一次combogrid使用的采坑经历/" class="next">记一次combogrid使用的采坑经历</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Calendar/">Calendar</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Calendar/问题/">问题</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Calendar/问题/后台/">后台</a></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/学习/">学习</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/学习/Hyper-V/">Hyper-V</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/学习/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/学习/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/学习/Java/并发/">并发</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/学习/前端/">前端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/学习/前端/js/">js</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/学习/前端/js/EasyUI/">EasyUI</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/学习/前端/js/EasyUI/Combo/">Combo</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/学习/前端/js/EasyUI/Combo/Datagrid/">Datagrid</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/学习/前端/js/EasyUI/Combo/Datagrid/Combogrid/">Combogrid</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/学习/前端/js/EasyUI/Combo/Datagrid/Combogrid/问题/">问题</a></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/学习/前端/js/EasyUI/JQuery/">JQuery</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/学习/前端/js/EasyUI/JQuery/问题/">问题</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Calendar/" style="font-size: 15px;">Calendar</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/CAS/" style="font-size: 15px;">CAS</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/EasyUI/" style="font-size: 15px;">EasyUI</a> <a href="/tags/Combo/" style="font-size: 15px;">Combo</a> <a href="/tags/Datagrid/" style="font-size: 15px;">Datagrid</a> <a href="/tags/Combogrid/" style="font-size: 15px;">Combogrid</a> <a href="/tags/问题/" style="font-size: 15px;">问题</a> <a href="/tags/前端/" style="font-size: 15px;">前端</a> <a href="/tags/Hyper-V/" style="font-size: 15px;">Hyper-V</a> <a href="/tags/虚拟化/" style="font-size: 15px;">虚拟化</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/后台/" style="font-size: 15px;">后台</a> <a href="/tags/虚拟机/" style="font-size: 15px;">虚拟机</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/问题排查/" style="font-size: 15px;">问题排查</a> <a href="/tags/OutOfMemoryError/" style="font-size: 15px;">OutOfMemoryError</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/教程/" style="font-size: 15px;">教程</a> <a href="/tags/版本控制系统/" style="font-size: 15px;">版本控制系统</a> <a href="/tags/感想/" style="font-size: 15px;">感想</a> <a href="/tags/深入理解Java虚拟机读书笔记/" style="font-size: 15px;">深入理解Java虚拟机读书笔记</a> <a href="/tags/JavaMail/" style="font-size: 15px;">JavaMail</a> <a href="/tags/base64/" style="font-size: 15px;">base64</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/04/26/解决JavaMail邮件出现base64乱码的问题/">解决JavaMail邮件出现base64乱码的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/28/CAS-Compare-and-Swap-原理学习/">CAS(Compare and Swap) 原理学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/26/Java并发学习笔记/">Java并发学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/27/记一次combogrid使用的采坑经历/">记一次combogrid使用的采坑经历</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/25/Java中返回一年中某一周的第一天/">Java中返回一年中某一周的第一天</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/16/EasyUI-layer-tips位置出错问题解决/">EasyUI layer.tips位置出错问题解决</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/15/使用easyUI组件combogrid面板相关问题/">使用easyUI组件combogrid面板相关问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/10/记一次tomcat崩溃问题排查过程/">记一次tomcat崩溃问题排查过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/07/Java应用问题排查笔记/">Java应用排查笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/04/第13章-线程安全与锁优化/">第13章 线程安全与锁优化</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://shalk.github.io/" title="shalk" target="_blank">shalk</a><ul></ul><a href="http://luckylau.tech/" title="luckylau" target="_blank">luckylau</a><ul></ul><a href="https://jimmysong.io/" title="Jimmy Song" target="_blank">Jimmy Song</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">WChCh's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>