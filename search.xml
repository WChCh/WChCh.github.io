<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[在Hyper-V系列文章之前]]></title>
    <url>%2F2017%2F11%2F03%2F%E5%9C%A8Hyper-V%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E4%B9%8B%E5%89%8D%2F</url>
    <content type="text"><![CDATA[目前正在做公司的项目就快要验收了，打算将项目中与Hyper-V相关的笔记做一个整理。项目中我们的云管平台需要接管用户的hyper-v虚拟机，能够实现对Hyper-V虚拟机的新建、删除、修改、启动、停止、web console、客户端 console等功能，由于首次接触Hyper-V相关的东西，我的Hyper-V系列文章主要记录我的一些学习过程，希望我记录的东西能够帮助到大家，因为能够完成这个项目阶段的开发也是离不开大家的帮助。]]></content>
      <categories>
        <category>技术</category>
        <category>学习</category>
        <category>Hyper-V</category>
      </categories>
      <tags>
        <tag>Hyper-V</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用教程]]></title>
    <url>%2F2017%2F11%2F03%2Fgit%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[打算要复习一下git的使用方法，搜了几篇不错的文章。我就不直接照搬全文了，连接如下： 比较全面的教程： Git使用教程,最详细，最傻瓜，最浅显，真正手把手教 针对几种应用场景的教程： git入门，先学会这几个姿势 常用命令详解：Git常用命令备忘，希望对学习Git的朋友们有所帮助 git进阶： 25个 Git 进阶技巧]]></content>
      <categories>
        <category>技术</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>教程</tag>
        <tag>版本控制系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第8章 虚拟机字节码执行引擎]]></title>
    <url>%2F2017%2F10%2F30%2F%E7%AC%AC8%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[在不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，可能能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎。 运行时栈帧结构栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。 栈帧存储了方法的局部变量表、操作数栈、动态链接和方法返回地址等信息。 在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。 局部变量表局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。 reference类型表示对一个对象实例的引用，虚拟机实现至少都应当能通过这个引用做到两点： 从此引用中直接或间接地查找到对象在Java堆中的数据存放的起始地址索引。 此引用中直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息，否则无法实现Java语言规范中定义的语法约束约束。 Java语言中明确的64位的数据类型只有long和double两种。对于64位的数据类型，虚拟机会以高位对齐的方式为其分配两个连续的Slot空间。 虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的Slot数量。 局部变量表中第0位索引的Slot默认是用于传递方法所属对象是的引用，在方法中可通过关键字“this”来访问到这个隐藏的参数。其余参数则按照参数表顺序排列，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用与分配其余的Slot。 局部变量与类变量不一样，如果一个局部变量定义了但没有赋初始值是不能使用的，不要认为java中任何情况下都存在诸如整型变量默认为0，布尔型变量默认为false等，如以下代码 12345//未赋值的局部变量public static void main(String [] args)&#123; int a; System.out.println(a);&#125; 操作数栈（理解是充当寄存器的角色）操作数栈也常称为操作栈，它是一个后入先出栈。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中。 操作数栈的每一个元素可以是任意的Java数据类型。32位数据类型所占的栈容量为1,64位数据类型所占的栈容量为2。 动态连接每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。 方法返回地址当一个方法开始执行后，只有两种方式可以退出这个方法： 正常退出 异常退出 方法推出的过程实际上就等同于把当前栈帧出栈，因此退出是可能执行的操作有： 回复上层方法的局部变量表和操作数栈； 把返回值压入调用者栈帧的操作数占中； 调整PC计数器的值以指向方法调用指令后面的一条指令等； 附加信息方法调用方法调用不等于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本，暂时还不涉及方法内部的具体运行过程。 解析所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在了加载的解析阶段，会将其中的一部分符号引用转化为直接引用。 静态方法、私有方法、实例构造器、父类方法、被final修饰的方法都适合在类加载阶段进行解析，将符号引用解析为该方法的直接引用，这些方法称为非虚方法。 解析调用一定是以静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。 分派分派调用过程将会揭示多态性特征的一些最基本的体现。 1 静态分派静态方法会在类加载期就进行解析，而静态方法显然也是可以拥有重载版本的，选择重载版本的而过程也是通过静态分派完成的。 2 动态分派它和多态性的另外一个重要体现—*重写有着很密切的关系。 3 单分派和多分派方法的接受者与方法的参数统称为方法的宗量，单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。 今天的Java语言是一门静态多分派、动态单分派的语言。 4 虚拟机动态分派的实现使用虚方法表索引来代替元数据查找以提高性能。 方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。 动态类型语言支持(重要)什么是动态类型语言：动态类型语言的关键特征是它的类型检查的主题过程是在运行期而不是编译期。 与运行时异常相对应的是连接时异常，例如很常见的NoClassDefFoundError便属于连接时异常。 基于栈的字节码解释执行引擎解释执行Javac编译器代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程，Java程序的编译就是半独立的实现。 基于栈的指令集与基于寄存器的指令集Java编译器输出的指令流，基本上是一种基于栈的指令集架构，指令流中的指令大比分都是零地址指令，它们依赖操作数栈进行工作。 基于栈的指令集主要的优点： 可移植； 代码相对更加紧凑 编译更加简单等 缺点： 完成相同功能需要的指令数量多。 频繁地访问内存，相对处理器来说，内存始终是执行速度额瓶颈； 基于栈的解释器执行过程]]></content>
      <categories>
        <category>技术</category>
        <category>学习</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>虚拟机</tag>
        <tag>JVM</tag>
        <tag>深入理解Java虚拟机读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第7章 虚拟机类加载机制]]></title>
    <url>%2F2017%2F10%2F30%2F%E7%AC%AC7%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。 在Java语言里，类型的加载、连接和初始化都是在程序运行期间完成的。 类加载的时机类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载。其中验证、准备、解析3个部分统称为连接。 解析阶段不一定：它在某些情况下可以在初始化阶段之后再开始，这个是为了支持Java语言的运行时绑定（也称动态绑定或晚期绑定）。 对于初始化阶段，虚拟机规范则是严格规定了有且只有5中情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）： 遇到new、getstatic、putstatic或invokestatic这4条字节指令时，如果类没有进行过初始化，则需要先触发其初始化。 使用java。lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要制定一个要执行的主类，虚拟机会先初始化这个主类。 5 当使用JDK1.7动态语言支持是，……. 这5中场景中的行为成为对一个类进行主动引用，除此之外，所有引用类的方式都不会触发初始化，成为被动引用。 类加载过程类加载的全过程，也就是加载、验证、准备、解析和初始化这个5个阶段。 1 加载在加载阶段，虚拟机需要完成一下3件事情： 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口，对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面。 数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的。 2 验证验证是连接阶段的第一步，目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 验证阶段的4个检验动作： 文件格式验证：通过这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的3个验证阶段全部都是基于方法区的存储结构进行的，不会再直接操作字节流。 元数据验证 字节码验证：确定程序语义是合法的、符合逻辑的。 符号引用验证 3 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。 注意：首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值。java程序的初始值赋值动作在初始化阶段才会执行。 特殊情况：如果类字段的字段属性表存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，假设上面类变量value的定义为： public static final int value = 123 编译时javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。因为关键字不但有static，还有final。 4 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或者接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行，分别对应于常量池的……..。 5 初始化类初始化阶段是类加载过程的最后一步。到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说字节码），是执行类构造器()方法的过程。 父类中定义的静态语句块要优先于子类的变量赋值操作。 类与类加载器双亲委派模型从Java虚拟机的角度将，只存在两种不同类型的类加载器：一种是启动类加载器，是虚拟机自身的一部分；另一种就是所有其他的类加载器。独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。 3种类型的类加载器： 启动类加载器：加载\lib目录中的并且是虚拟机识别的类库加载到虚拟机内存中。改加载器无法被Java程序直接引用。 扩展类加载器：加载\lib\ext目录中的类库。开发者可以直接使用。 应用程序类加载器：负责加载用户类路径（ClassPath）上所指定的类库。 如果有必要，还可以加入自己定义的类加载器。 这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父类加载器的代码。 双亲委派模型的工作过程：……..。 破坏双亲委派模型]]></content>
      <categories>
        <category>技术</category>
        <category>学习</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>虚拟机</tag>
        <tag>JVM</tag>
        <tag>深入理解Java虚拟机读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第6章 类文件结构]]></title>
    <url>%2F2017%2F10%2F30%2F%E7%AC%AC6%E7%AB%A0-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[无关性的基石各种不同平台的虚拟机与所有平台都统一使用的程序存储格式—字节码(ByteCode)是构成平台无关性的基石。无关性： 平台无关性 语言无关性实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class”这种特定的二进制文件格式所关联。 Class类文件的结构 任何一个Class文件都对应着唯一一个类或是接口的定义信息，但反过来说，类或接口并不一定都得定义在文件里。 Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑第排列在Class文件中，中间没有任何分隔符。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储（大端模式）。 Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种结构中只有两种数据类型：无符号数和表。 无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串。 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。整个Class文件本质上就是一张表。 魔数与Class文件的版本 每个Class文件的头4个字节称为魔数，唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件，使用魔数不是扩展名来进行识别主要是基于安全方面的考虑，值为：0xCAFEBABE。 紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号，第7和第8个字节是主版本号。 常量池紧接着主次版本号之后的是常量池入口，常量池可以理解为Class文件中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时他还是在Class文件中第一个出现的表类型数据项目。 常量池容量计数器是从1开始计数的，表示常量的个数。常量翅中主要存放两大类常量： 字面量 符号引用 字面量比较接近于Java语言层面的常量概念，如字符串、声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括了下面的三类常量： 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符常量池中每一个常量都是一个表。 常量池容量为21，表示有21项常量 由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名称，所以CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度。而这里的最大长度就是length的最大值，既u2类型能表达的最大值65535.所以Java程序中如果定义了超过65KB因为字符串的变量或方法名将会无法编译。 javap工具用于分析Class文件字节码的。 访问标志这个标志用于识别一些类或者是接口层次的访问信息。 类索引、父类索引与接口索引集合Class文件中由这三项数据来确定这个类的继承关系。 字段表集合字段表用于描述接口库或者类中声明的变量。 字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。 字段表集合中不会列出从超类或者父类接口中继承而来的字段，但有可能列出原本Java代码中不存在的字段。对于字节码来说，如果两个字段的描述符不一致，那字段重名就是合法的。 方发表集合volatile关键字和transient关键字不能修饰方法，所以方发表的访问标志中没有了ACC_VOLATITE标志和ACC_TRANSIENT标志。 属性表集合在Class文件、字段表、方发表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。操作栈数？max_stack代表了操作数栈深度的最大值。在方法执行的任意时刻，操作栈数都不会超过这个深度。虚拟机运行的时候需要根据这个值来分配栈帧中的操作栈深度。 1 Code属性了解Code属性是学习后面关于字节码执行引擎内容的必要基础，能直接阅读字节码也是工作中分析Java代码语义问题的必要工具和基本技能。 使用Javap 命令计算字节码指令： javap -verbose TestClass 在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留第一个Slot位来存放对象实例的引用，方法参数值从1开始计算。，这个处理只对实例方法有效。 2 Exceptions属性Exceptions属性的作用是列举出方法中可能抛出的受检查异常(Checked Exceptions)，也就是方法描述时在throws关键字后面列举的异常。 3 LineNumberTable属性LineNumberTable属性用于描述Java源码行号与字节码行号之间的对应关系。 4 LocalVariableTable属性LocalVariableTable属性用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系 5 SourceFile属性SourceFile属性用于记录生成这个Class文件的源码文件名称。 6 ConstantValue属性ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。onstantValue的属性值只能限于基本类型和String。 7 InnerClasses属性InnerClasses属性用于记录内部类与宿主类之间的关联。 8 Deprecated及Synthetic属性9 StackMapTable属性10 Signature11 BootstrapMethods属性字节码指令简介Java虚拟机的指令由一个字节长度、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands）而构成。 1 字节码与数据结构阅读字节码作为了解Java虚拟机的基础技能，是一项应当熟练掌握的能力。 2 加载和存储指令加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输。 3 运算指令运算指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。 算术指令分为两种： 对整型数据进行运算的指令。 对浮点型数据进行运算的指令。 无论哪种算术指令，都使用Java虚拟机的数据类型，由于没有直接支持byte，short，char和boolean类型的算术指令，对于这类数据的运算，应使用操作int类型的指令代替。 4 类型转换指令5 对象创建与访问指令6 操作数栈管理指令操作数栈的指令： 将操作数栈的栈顶一个或两个元素出栈：pop、pop2。 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup_x2、dup2_x2。 将栈最顶端的两个数值互换：swap。 7 控制转移指令8 方法调用和返回指令9 异常处理指令10 同步指令共有设计和私有设计]]></content>
      <categories>
        <category>技术</category>
        <category>学习</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>虚拟机</tag>
        <tag>JVM</tag>
        <tag>深入理解Java虚拟机读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第5章 调优案例分析与实战]]></title>
    <url>%2F2017%2F10%2F30%2F%E7%AC%AC5%E7%AB%A0-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[高性能硬件上的程序部署策三大块非用户程序时间： 编译时间 垃圾收集时间 GC时间 新生代minor GC 老年代Full GC编译时间是指虚拟机的JIT编译器编译热点代码的耗时。Java的运行时编译最大的缺点就是它进行编译需要消耗程序正常的运行时间。]]></content>
      <categories>
        <category>技术</category>
        <category>学习</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>虚拟机</tag>
        <tag>JVM</tag>
        <tag>深入理解Java虚拟机读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第4章 虚拟机性能监控与故障处理工具]]></title>
    <url>%2F2017%2F10%2F30%2F%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[概述给定一个系统定位问题的时候，只是、经验是关键基础，数据时依据，工具是运用知识处理数据的手段。这里说的数据包括：运行日志、异常对战、GC日志、线程快照（threaddump/jvacore文件）、堆转存储快照（headdump/hprof文件）等。 JDK的命令行工具 解决liunx下jstat无法查看虚拟机状态的问题：连接。 启动后,这时候使用jstat查看该tomcat的状态提示pid not found,使用jps也没有这条信息,但是ps查看明明就有,顿时感觉很坑爹.一顿查找资料后,逐步解决.首先java进程会向/tmp里写文件,路径为hsperfdata$user/$pid,如果在tmp下没有这个文件jps就会查找不到这个线程.如果tmp下的java临时文件有误就会提示xx – process information unavailable,这时候把tmp下hsperfdata这样的都删了,然后重启java程序,再使用jps就能正常输出结果了. 然后tomcat的catalina.sh里开头设置CATALINA_TMPDIR=/tmp,这样下面的脚本执行-Djava.io.tmpdir=\”$CATALINA_TMPDIR\” \,这样就可以达到效果是加上java参数-Djava.io.tmpdir=/tmp.这时候重启tomcat后,输入jstat -gcutil pid,就可以显示jvm的情况了]]></content>
      <categories>
        <category>技术</category>
        <category>学习</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>虚拟机</tag>
        <tag>JVM</tag>
        <tag>深入理解Java虚拟机读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第3章 垃圾收集器与内存分配策略]]></title>
    <url>%2F2017%2F10%2F30%2F%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[概述 每个栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作，每一个栈帧中分配多少内存基本上是在类结构确定下来是就已知的。 程序计数器、虚拟机栈、本地方法栈这几个区域的内存分配和回收都具备确定性，不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟着回收了。而java堆和方法区则不一样。 对象已死吗Java堆回收 主流的java虚拟机里面没有选用引用计数器算法来管理内存，其中最主要的原因是它很难解决对象之间互相循环引用的问题。 通过可达性分析算法来判定对象是否存活着，算法思路：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。 可作为GC Roots的对象包括下面几种: 虚拟机栈（栈帧中的本地变量表）中引用的对象。 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI引用的对象 java将引用分为强引用、软引用、弱引用、虚引用，引用强度逐渐减弱。 可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。 finalize()方法中对象逃脱死亡命运的最后一次机会。 任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会再次被执行。尽量避免使用它。 方法区回收 Java虚拟机规范中确实说过可以不要求虚拟机在方法区(永久代)实现垃圾收集。 永久代的垃圾回收主要回收两部分内容：废弃产量和无用的类。 无用的类： 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何引用。 加载该类的ClassLoader已经被回收。 该类对用的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 垃圾收集算法 什么是新生代、永久代、老年代 HotSpot的算法实现以下是介绍如何发起内存回收，还没回收： 枚举根节点； 安全点中断方式：抢先式中断、主动式中断，几乎没有虚拟机采用抢先式中断； 安全区域：解决了“不执行的线程”无法到达安全点的问题。安全区域是指在一段代码片段之中，引用关系不会发生变化。 垃圾收集器（真正回收）真正回收垃圾 Serial收集器（新生代收集器，client模式下是很好的选择，单CPU下效果好） ParNew收集器：Serial多线程版本（Server模式下首选新生代收集器） Parallel Scavenge收集器（新生代）：吞吐量优先的收集器 Serial Old收集器（老年代） CMS收集器（老年代）：以获取最短回收停顿时间为目标的收集器。步骤： 初始标志 并发标志 重新标志 并发清除 G1收集器（新生代、老年代），优点： 并行与并发 分代收集（新生代、老年代） 空间整合（整体：标记-整理实现，局部复制算法实现） 可预测的停顿 步骤： 初始标记 并发标记 最终标记 筛选回收 理解GC日志阅读GC日志是处理Java虚拟机内存问题的基础技能。 内存分配与回收策略给对象分配内存，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。 几条最普遍的内存分配规则 对象优先在Eden分配，-Xmn10M表示10M分配给了新生代；-XX:SurvivorRatio=8决定了新生代中Eden区与一个Survivor区的空间比例是8:1. Minor GC和Full GC有什么不一样吗？ 大对象直接进入老年代最典型的大对象就是那种很长的字符串以及数组。虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。 长期存活的对象将进入老年代 对象晋升老年代的年龄阈值，可以通过参数：-XX:MaxTenuringThreshold设置。 1 对象优先在Eden中分配，当Eden中没有足够的空间分配时会促发一次Minor GC。每次Minor GC结束后，Eden区会清空，因为它会把Eden中还依然存活的对象放到Survivor中，当Survivor中放不下时，则由分派担保进入老年代中。2 大对象直接进入老年代中。-XX:+PretenuerSizeThreshold 控制”大对象的“的大小。即当创建的对象大于这个临界值时，则该对象直接进入老年代。3 长期存活的对象将进入老年代。虚拟机对每个对象定义了一个对象年龄（Age）计数器。当年龄增加到一定的临界值时，就会晋升到老年代中，该临界值由参数：-XX:MaxTenuringThreshold来设置。如果对象在Eden出生并在第一次发生Minor GC时仍然存活，并且能够被Survivor中所容纳的话，则该对象会被移动到Survivor中，并且设Age=1；以后每经历一次Minor GC，该对象还存活的话会被移动到另一个Survivor区中，并且Age=Age+1。4 动态对象年龄判定：如上所示，虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升到老年代，如果在Survivor区中相同年龄（设年龄为age）的对象的所有大小之和超过Survivor空间的一半，年龄大于或等于该年龄（age）的对象就可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。 动态对象年龄判定如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。 空间分配担保每一次回收晋升到老年代对象容量的平均大小值最为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多的空间。老年代空间不足会出现担保失败。 总结内存回收与垃圾收集器在很多时候都是影响系统性能、并发能力的主要因素之一，虚拟机之所以提供多种不同的收集器以及提供大量的调节参数，是因为只有根据实际应用需求、实现方式选择最优的收集方式才能获取最高的性能。]]></content>
      <categories>
        <category>技术</category>
        <category>学习</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>虚拟机</tag>
        <tag>JVM</tag>
        <tag>深入理解Java虚拟机读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第2章 Java内存区域与内存溢出异常]]></title>
    <url>%2F2017%2F10%2F30%2F%E7%AC%AC2%E7%AB%A0-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[计数器 字节码解释器工作时通过改变计数器的值来选取下一条需要执行的字节码指令。 每个线程有独立的计数器。 如果正在执行的是Native方法，这个计数器值为空（Undefined)。 计数器的内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 虚拟机栈 与计数器一样，虚拟机栈也是线程私有的，生命周期与线程相同。 描述的是Java方法执行的内存模型 栈帧是方法运行时的基础数据结构。 Java虚拟机规范对这个区域规定了两种异常情况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。本地方法栈 为虚拟机使用到的Native方法服务。 本地方法栈也会抛出StackOverflowError和OutOfMemory异常。 与虚拟机栈的作用相似。 Java堆 Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。以为目的是存放对象实例。 是垃圾收集器管理的主要区域。 堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 方法区 也是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 除了和java堆一样不需要连续的内存和可以选择规定大小或者可扩展外，还可以选择不实现垃圾收集。 这区域的内存回收目标主要是针对常量池的回收和对类型的卸载。 无法满足内存分配的需求时，将会抛出OutOfMemoryError异常。 运行时常量池 是方法区一部分。 常量池用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池存放。 直接内存 NIO 对象的创建 对象在堆上的内存分配方式分为指针碰撞和空闲列表。 对象内存空间分配完成后，内存空间都初始化为零值。 对象的内存布局 在内存中的布局分为3块区域：对象头、实例数据、对齐填充 对象的定位 通过栈上的reference数据来操作堆上的具体数据。 目前主流的访问方式有使用句柄和直接指针两种。 排错 注意区分是内存泄露(Memory Leak)，还是内存溢出(Memory Overflow) 使用Eclipse Memory Analyzer进行分析，安装教程：http://www.jianshu.com/p/3b3c3a914724 堆溢出 堆空间中的每个对象都是由一个根元素为起点被层层调用的。因此，一个对象还被某一个存活的根元素所引用，就会被认为是存活对象，不能被回收，进行内存释放。因此，我们可以通过分析一个对象到根元素的引用路径来分析为什么该对象不能被顺利回收。如果说一个对象已经不被任何程序逻辑所需要但是还存在被根元素引用的情况，我们可以说这里存在内存泄露。 -Xmx20m -Xms20m 设置堆的最大最小；-Xss128k 设置虚拟机栈的大小；-Xoss设置本地方法栈大小；MaxPermSize(最大方法区容量) 虚拟机栈和本地方法栈溢出 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflow异常（栈溢出）；如果虚拟机在扩展栈时无法申请到足够的内存空间，则将抛出OutOfMemoryError异常（内存泄露）。 为了防止多线程导致的内存溢出，要注意控制虚拟机栈和本地方法栈的大小。 方法区和运行时常量池溢出运行时常量区是方法区的一部分。 String.intern()方法在JDK1.7之后的改变，注意“首次出现原则”。 本机直接内存溢出 DirectMemory容量可通过 -XX: MaxDirectMemorySize指定，如果不指定则默认与Java堆最大值（-Xmx指定）一样。 由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中是不会看见明显的异常，如果读者返现OOM之后Dump文件很小，而程序中有直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。]]></content>
      <categories>
        <category>技术</category>
        <category>学习</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>虚拟机</tag>
        <tag>JVM</tag>
        <tag>深入理解Java虚拟机读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第1章 走进Java]]></title>
    <url>%2F2017%2F10%2F30%2F%E7%AC%AC1%E7%AB%A0-%E8%B5%B0%E8%BF%9BJava%2F</url>
    <content type="text"><![CDATA[java优点 摆脱平台束缚； 提供一个相对安全的内存管理和访问机制，避免了绝大部分的内存泄露和指针越界问题 实现了热点代码监测和运行时编译及优化 有一套完善的应用程序接口，还有无数来自商业机构和开源社区的第三方类库来帮助它实现各种各样的功能 java技术体系Java程序设计语言、Java虚拟机、Java API类库这三部分统称为JDK，JDK是用于支持Java程序开发的最小环境 Java类库中的Java SE API子集和Java虚拟机这两部分统称为JRE，JRE是支持Java程序运行的标准环境。]]></content>
      <categories>
        <category>技术</category>
        <category>学习</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>虚拟机</tag>
        <tag>JVM</tag>
        <tag>深入理解Java虚拟机读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2017%2F10%2F30%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[首先要纪念一下，这是我第一次写博客，这也是我的第一篇博文。我希望以后几年，十几年，几十年都能够坚持写下去，与大家分享生活与工作中一切好的东西！ 我一直都想把工作和生活中的点点滴滴以博文的方式跟大家分享，但是一直都没有付诸行动（其实就是懒），直到前段时间跟同一年以应届生身份进公司的同事聊天时才知道他一直在坚持写博客，他向我推荐了他的博客，还告诉我怎么去搭建博客站点（这里要感谢github），这才完全激起了我的兴趣。当然我不希望自己只有三分钟热度，我希望自己能够一直写下去。 当然，不只是一时兴起，我打算写博客还基于几个原因： 我一直是分享的受益者，这些年通过大家的分享帮助我解决了很多问题，因此，我希望尽最大努力回馈大家； 将工作中遇到的一些坑或是解决的某些技术问题做一个总结，以备后期查阅； 记录技术与生活相关的学习笔记，展示自己的技术栈，督促自己必须不断地学习； 写一些生活感想，记录一些生活的美好瞬间； 加油吧，少年！（嘿嘿）]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
</search>
