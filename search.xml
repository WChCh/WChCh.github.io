<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[第3章 垃圾收集器与内存分配策略]]></title>
      <url>/2017/10/30/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ol>
<li>每个栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作，每一个栈帧中分配多少内存基本上是在类结构确定下来是就已知的。</li>
<li>程序计数器、虚拟机栈、本地方法栈这几个区域的内存分配和回收都具备确定性，不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟着回收了。而java堆和方法区则不一样。</li>
</ol>
<h4 id="对象已死吗"><a href="#对象已死吗" class="headerlink" title="对象已死吗"></a>对象已死吗</h4><h5 id="Java堆回收"><a href="#Java堆回收" class="headerlink" title="Java堆回收"></a>Java堆回收</h5><ol>
<li>主流的java虚拟机里面没有选用引用计数器算法来管理内存，其中最主要的原因是它很难解决对象之间互相循环引用的问题。</li>
<li>通过可达性分析算法来判定对象是否存活着，算法思路：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</li>
<li>可作为GC Roots的对象包括下面几种:<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI引用的对象</li>
</ol>
</li>
<li>java将引用分为强引用、软引用、弱引用、虚引用，引用强度逐渐减弱。</li>
<li>可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。</li>
<li>finalize()方法中对象逃脱死亡命运的最后一次机会。</li>
<li>任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会再次被执行。尽量避免使用它。</li>
</ol>
<a id="more"></a>
<h5 id="方法区回收"><a href="#方法区回收" class="headerlink" title="方法区回收"></a>方法区回收</h5><ol>
<li>Java虚拟机规范中确实说过可以不要求虚拟机在方法区(永久代)实现垃圾收集。</li>
<li>永久代的垃圾回收主要回收两部分内容：废弃产量和无用的类。</li>
<li>无用的类：<ol>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何引用。</li>
<li>加载该类的ClassLoader已经被回收。</li>
<li>该类对用的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ol>
</li>
</ol>
<h5 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h5><ol>
<li>什么是新生代、永久代、老年代</li>
</ol>
<h5 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h5><p>以下是介绍如何发起内存回收，还没回收：</p>
<ol>
<li>枚举根节点；</li>
<li>安全点中断方式：抢先式中断、主动式中断，几乎没有虚拟机采用抢先式中断；</li>
<li>安全区域：解决了“不执行的线程”无法到达安全点的问题。安全区域是指在一段代码片段之中，引用关系不会发生变化。</li>
</ol>
<h5 id="垃圾收集器（真正回收）"><a href="#垃圾收集器（真正回收）" class="headerlink" title="垃圾收集器（真正回收）"></a>垃圾收集器（真正回收）</h5><p>真正回收垃圾</p>
<ol>
<li>Serial收集器（新生代收集器，client模式下是很好的选择，单CPU下效果好）</li>
<li>ParNew收集器：Serial多线程版本（Server模式下首选新生代收集器）</li>
<li>Parallel Scavenge收集器（新生代）：吞吐量优先的收集器</li>
<li>Serial Old收集器（老年代）</li>
<li>CMS收集器（老年代）：以获取最短回收停顿时间为目标的收集器。步骤：<ol>
<li>初始标志</li>
<li>并发标志</li>
<li>重新标志</li>
<li>并发清除</li>
</ol>
</li>
<li><p>G1收集器（新生代、老年代），优点：</p>
<ol>
<li>并行与并发</li>
<li>分代收集（新生代、老年代）</li>
<li>空间整合（整体：标记-整理实现，局部复制算法实现）</li>
<li><p>可预测的停顿</p>
<p>步骤：</p>
</li>
<li><p>初始标记</p>
</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ol>
</li>
</ol>
<h5 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h5><p>阅读GC日志是处理Java虚拟机内存问题的基础技能。</p>
<h4 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h4><p>给对象分配内存，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。</p>
<p>几条最普遍的内存分配规则</p>
<ol>
<li>对象优先在Eden分配，-Xmn10M表示10M分配给了新生代；-XX:SurvivorRatio=8决定了新生代中Eden区与一个Survivor区的空间比例是8:1.</li>
<li>Minor GC和Full GC有什么不一样吗？</li>
</ol>
<h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>最典型的大对象就是那种很长的字符串以及数组。虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。</p>
<h4 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h4><ol>
<li>对象晋升老年代的年龄阈值，可以通过参数：-XX:MaxTenuringThreshold设置。</li>
<li>1 对象优先在Eden中分配，当Eden中没有足够的空间分配时会促发一次Minor GC。每次Minor GC结束后，Eden区会清空，因为它会把Eden中还依然存活的对象放到Survivor中，当Survivor中放不下时，则由分派担保进入老年代中。2 大对象直接进入老年代中。-XX:+PretenuerSizeThreshold 控制”大对象的“的大小。即当创建的对象大于这个临界值时，则该对象直接进入老年代。3 长期存活的对象将进入老年代。虚拟机对每个对象定义了一个对象年龄（Age）计数器。当年龄增加到一定的临界值时，就会晋升到老年代中，该临界值由参数：-XX:MaxTenuringThreshold来设置。如果对象在Eden出生并在第一次发生Minor GC时仍然存活，并且能够被Survivor中所容纳的话，则该对象会被移动到Survivor中，并且设Age=1；以后每经历一次Minor GC，该对象还存活的话会被移动到另一个Survivor区中，并且Age=Age+1。4 动态对象年龄判定：如上所示，虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升到老年代，如果在Survivor区中相同年龄（设年龄为age）的对象的所有大小之和超过Survivor空间的一半，年龄大于或等于该年龄（age）的对象就可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。</li>
</ol>
<h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><p>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>每一次回收晋升到老年代对象容量的平均大小值最为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多的空间。老年代空间不足会出现担保失败。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>内存回收与垃圾收集器在很多时候都是影响系统性能、并发能力的主要因素之一，虚拟机之所以提供多种不同的收集器以及提供大量的调节参数，是因为只有根据实际应用需求、实现方式选择最优的收集方式才能获取最高的性能。</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
            <category> 学习 </category>
            
            <category> JVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 虚拟机 </tag>
            
            <tag> JVM </tag>
            
            <tag> 深入理解Java虚拟机读书笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[第2章 Java内存区域与内存溢出异常]]></title>
      <url>/2017/10/30/%E7%AC%AC2%E7%AB%A0-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
      <content type="html"><![CDATA[<h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><ol>
<li>字节码解释器工作时通过改变计数器的值来选取下一条需要执行的字节码指令。</li>
<li>每个线程有独立的计数器。</li>
<li>如果正在执行的是Native方法，这个计数器值为空（Undefined)。</li>
<li>计数器的内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</li>
</ol>
<h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><ol>
<li>与计数器一样，虚拟机栈也是线程私有的，生命周期与线程相同。</li>
<li>描述的是Java方法执行的内存模型</li>
<li>栈帧是方法运行时的基础数据结构。</li>
<li>Java虚拟机规范对这个区域规定了两种异常情况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4></li>
<li>为虚拟机使用到的Native方法服务。</li>
<li>本地方法栈也会抛出StackOverflowError和OutOfMemory异常。</li>
<li>与虚拟机栈的作用相似。</li>
</ol>
<h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><ol>
<li>Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。以为目的是存放对象实例。</li>
<li>是垃圾收集器管理的主要区域。</li>
<li>堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</li>
</ol>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><ol>
<li>也是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li>
<li>除了和java堆一样不需要连续的内存和可以选择规定大小或者可扩展外，还可以选择不实现垃圾收集。</li>
<li>这区域的内存回收目标主要是针对常量池的回收和对类型的卸载。</li>
<li>无法满足内存分配的需求时，将会抛出OutOfMemoryError异常。</li>
</ol>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ol>
<li>是方法区一部分。</li>
<li>常量池用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池存放。</li>
</ol>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><ol>
<li>NIO</li>
</ol>
<h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><ol>
<li>对象在堆上的内存分配方式分为指针碰撞和空闲列表。</li>
<li>对象内存空间分配完成后，内存空间都初始化为零值。</li>
</ol>
<h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><ol>
<li>在内存中的布局分为3块区域：对象头、实例数据、对齐填充</li>
</ol>
<h4 id="对象的定位"><a href="#对象的定位" class="headerlink" title="对象的定位"></a>对象的定位</h4><ol>
<li>通过栈上的reference数据来操作堆上的具体数据。</li>
<li>目前主流的访问方式有使用句柄和直接指针两种。</li>
</ol>
<h4 id="排错"><a href="#排错" class="headerlink" title="排错"></a>排错</h4><ol>
<li>注意区分是内存泄露(Memory Leak)，还是内存溢出(Memory Overflow)</li>
<li>使用Eclipse Memory Analyzer进行分析，安装教程：<a href="http://www.jianshu.com/p/3b3c3a914724" target="_blank" rel="external">http://www.jianshu.com/p/3b3c3a914724</a></li>
</ol>
<h5 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h5><ol>
<li>堆空间中的每个对象都是由一个根元素为起点被层层调用的。因此，一个对象还被某一个存活的根元素所引用，就会被认为是存活对象，不能被回收，进行内存释放。因此，我们可以通过分析一个对象到根元素的引用路径来分析为什么该对象不能被顺利回收。如果说一个对象已经不被任何程序逻辑所需要但是还存在被根元素引用的情况，我们可以说这里存在内存泄露。</li>
<li>-Xmx20m -Xms20m 设置堆的最大最小；-Xss128k 设置虚拟机栈的大小；-Xoss设置本地方法栈大小；MaxPermSize(最大方法区容量)</li>
</ol>
<h5 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h5><ol>
<li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflow异常（栈溢出）；如果虚拟机在扩展栈时无法申请到足够的内存空间，则将抛出OutOfMemoryError异常（内存泄露）。</li>
<li>为了防止多线程导致的内存溢出，要注意控制虚拟机栈和本地方法栈的大小。</li>
</ol>
<h5 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h5><p>运行时常量区是方法区的一部分。</p>
<ol>
<li>String.intern()方法在JDK1.7之后的改变，注意“首次出现原则”。</li>
</ol>
<h5 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h5><ol>
<li>DirectMemory容量可通过 -XX: MaxDirectMemorySize指定，如果不指定则默认与Java堆最大值（-Xmx指定）一样。</li>
<li>由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中是不会看见明显的异常，如果读者返现OOM之后Dump文件很小，而程序中有直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
            <category> 学习 </category>
            
            <category> JVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 虚拟机 </tag>
            
            <tag> JVM </tag>
            
            <tag> 深入理解Java虚拟机读书笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[第1章 走进Java]]></title>
      <url>/2017/10/30/%E7%AC%AC1%E7%AB%A0-%E8%B5%B0%E8%BF%9BJava/</url>
      <content type="html"><![CDATA[<h3 id="java优点"><a href="#java优点" class="headerlink" title="java优点"></a>java优点</h3><ol>
<li>摆脱平台束缚；</li>
<li>提供一个相对安全的内存管理和访问机制，避免了绝大部分的内存泄露和指针越界问题</li>
<li>实现了热点代码监测和运行时编译及优化</li>
<li>有一套完善的应用程序接口，还有无数来自商业机构和开源社区的第三方类库来帮助它实现各种各样的功能</li>
</ol>
<a id="more"></a>
<h3 id="java技术体系"><a href="#java技术体系" class="headerlink" title="java技术体系"></a>java技术体系</h3><p><em>Java程序设计语言、Java虚拟机、Java API类库这三部分统称为JDK，JDK是用于支持Java程序开发的最小环境</em></p>
<p><em>Java类库中的Java SE API子集和Java虚拟机这两部分统称为JRE，JRE是支持Java程序运行的标准环境。</em></p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
            <category> 学习 </category>
            
            <category> JVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 虚拟机 </tag>
            
            <tag> JVM </tag>
            
            <tag> 深入理解Java虚拟机读书笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的第一篇博客]]></title>
      <url>/2017/10/30/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>首先要纪念一下，这是我第一次写博客，这也是我的第一篇博文。我希望以后几年，十几年，几十年都能够坚持写下去，与大家分享生活与工作中一切好的东西！</p>
<a id="more"></a>
<p>我一直都想把工作和生活中的点点滴滴以博文的方式跟大家分享，但是一直都没有付诸行动（其实就是懒），直到前段时间跟同一年以应届生身份进公司的同事聊天时才知道他一直在坚持写博客，他向我推荐了他的博客，还告诉我怎么去搭建博客站点（这里要感谢github），这才完全激起了我的兴趣。当然我不希望自己只有三分钟热度，我希望自己能够一直写下去。</p>
<p>当然，不只是一时兴起，我打算写博客还基于几个原因：</p>
<ol>
<li>我一直是分享的受益者，这些年通过大家的分享帮助我解决了很多问题，因此，我希望尽最大努力回馈大家；</li>
<li>将工作中遇到的一些坑或是解决的某些技术问题做一个总结，以备后期查阅；</li>
<li>记录技术与生活相关的学习笔记，展示自己的技术栈，督促自己必须不断地学习；</li>
<li>写一些生活感想，记录一些生活的美好瞬间；</li>
</ol>
<p>加油吧，少年！（嘿嘿）</p>
]]></content>
      
        <categories>
            
            <category> 生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 感想 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
