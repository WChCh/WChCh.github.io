<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="woaiwchch@126.com"><title>WChCh's Blog | Coding My Life</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">WChCh's Blog</h1><a id="logo" href="/.">WChCh's Blog</a><p class="description">Coding My Life</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"><a href="/2017/10/30/第8章-虚拟机字节码执行引擎/">第8章 虚拟机字节码执行引擎</a></h1><div class="post-meta">2017-10-30</div><div class="post-content"><p>在不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，可能能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎。</p>
<h4 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h4><p>栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。</p>
<p>栈帧存储了方法的局部变量表、操作数栈、动态链接和方法返回地址等信息。</p>
<p>在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</p>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。</p>
<p>reference类型表示对一个对象实例的引用，虚拟机实现至少都应当能通过这个引用做到两点：</p>
<ol>
<li>从此引用中直接或间接地查找到对象在Java堆中的数据存放的起始地址索引。</li>
<li>此引用中直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息，否则无法实现Java语言规范中定义的语法约束约束。</li>
</ol>
<p>Java语言中明确的64位的数据类型只有long和double两种。对于64位的数据类型，虚拟机会以高位对齐的方式为其分配两个连续的Slot空间。</p>
<p>虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的Slot数量。</p>
<p>局部变量表中第0位索引的Slot默认是用于传递方法所属对象是的引用，在方法中可通过关键字“this”来访问到这个隐藏的参数。其余参数则按照参数表顺序排列，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用与分配其余的Slot。</p>
<p><strong>局部变量与类变量不一样，如果一个局部变量定义了但没有赋初始值是不能使用的，不要认为java中任何情况下都存在诸如整型变量默认为0，布尔型变量默认为false等，如以下代码</strong></p></div><p class="readmore"><a href="/2017/10/30/第8章-虚拟机字节码执行引擎/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/10/30/第7章-虚拟机类加载机制/">第7章 虚拟机类加载机制</a></h1><div class="post-meta">2017-10-30</div><div class="post-content"><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p>
<p>在Java语言里，类型的加载、连接和初始化都是在程序运行期间完成的。</p>
<h4 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h4><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载。其中验证、准备、解析3个部分统称为连接。</p>
<p>解析阶段不一定：它在某些情况下可以在初始化阶段之后再开始，这个是为了支持Java语言的运行时绑定（也称动态绑定或晚期绑定）。</p>
<p>对于初始化阶段，虚拟机规范则是严格规定了有且只有5中情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这4条字节指令时，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>使用java。lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要制定一个要执行的主类，虚拟机会先初始化这个主类。</li>
<li>5 当使用JDK1.7动态语言支持是，…….</li>
</ol>
<p>这5中场景中的行为成为对一个类进行主动引用，除此之外，所有引用类的方式都不会触发初始化，成为被动引用。</p>
<h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><p>类加载的全过程，也就是加载、验证、准备、解析和初始化这个5个阶段。</p>
<h5 id="1-加载"><a href="#1-加载" class="headerlink" title="1 加载"></a>1 加载</h5><p>在加载阶段，虚拟机需要完成一下3件事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口，对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面。</li>
</ol></div><p class="readmore"><a href="/2017/10/30/第7章-虚拟机类加载机制/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/10/30/第6章-类文件结构/">第6章 类文件结构</a></h1><div class="post-meta">2017-10-30</div><div class="post-content"><h4 id="无关性的基石"><a href="#无关性的基石" class="headerlink" title="无关性的基石"></a>无关性的基石</h4><p>各种不同平台的虚拟机与所有平台都统一使用的程序存储格式—字节码(ByteCode)是构成平台无关性的基石。<br>无关性：</p>
<ol>
<li>平台无关性</li>
<li>语言无关性<br>实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class”这种特定的二进制文件格式所关联。</li>
</ol>
<h4 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h4><ol>
<li>任何一个Class文件都对应着唯一一个类或是接口的定义信息，但反过来说，类或接口并不一定都得定义在文件里。</li>
<li>Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑第排列在Class文件中，中间没有任何分隔符。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储（大端模式）。</li>
<li>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种结构中只有两种数据类型：无符号数和表。</li>
<li>无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串。</li>
<li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。整个Class文件本质上就是一张表。</li>
</ol>
<h5 id="魔数与Class文件的版本"><a href="#魔数与Class文件的版本" class="headerlink" title="魔数与Class文件的版本"></a>魔数与Class文件的版本</h5><ol>
<li>每个Class文件的头4个字节称为魔数，唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件，使用魔数不是扩展名来进行识别主要是基于安全方面的考虑，值为：0xCAFEBABE。</li>
<li>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号，第7和第8个字节是主版本号。</li>
</ol>
<h5 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h5><p>紧接着主次版本号之后的是常量池入口，常量池可以理解为Class文件中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时他还是在Class文件中第一个出现的表类型数据项目。</p>
<p>常量池容量计数器是从1开始计数的，表示常量的个数。<br>常量翅中主要存放两大类常量：</p>
<ol>
<li>字面量</li>
<li>符号引用</li>
</ol></div><p class="readmore"><a href="/2017/10/30/第6章-类文件结构/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/10/30/第5章-调优案例分析与实战/">第5章 调优案例分析与实战</a></h1><div class="post-meta">2017-10-30</div><div class="post-content"><h4 id="高性能硬件上的程序部署策"><a href="#高性能硬件上的程序部署策" class="headerlink" title="高性能硬件上的程序部署策"></a>高性能硬件上的程序部署策</h4><p>三大块非用户程序时间：</p>
<ol>
<li>编译时间</li>
<li>垃圾收集时间</li></div><p class="readmore"><a href="/2017/10/30/第5章-调优案例分析与实战/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/10/30/第4章-虚拟机性能监控与故障处理工具/">第4章 虚拟机性能监控与故障处理工具</a></h1><div class="post-meta">2017-10-30</div><div class="post-content"><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>给定一个系统定位问题的时候，只是、经验是关键基础，数据时依据，工具是运用知识处理数据的手段。这里说的数据包括：运行日志、异常对战、GC日志、线程快照（threaddump/jvacore文件）、堆转存储快照（headdump/hprof文件）等。</p></div><p class="readmore"><a href="/2017/10/30/第4章-虚拟机性能监控与故障处理工具/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/10/30/第3章-垃圾收集器与内存分配策略/">第3章 垃圾收集器与内存分配策略</a></h1><div class="post-meta">2017-10-30</div><div class="post-content"><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ol>
<li>每个栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作，每一个栈帧中分配多少内存基本上是在类结构确定下来是就已知的。</li>
<li>程序计数器、虚拟机栈、本地方法栈这几个区域的内存分配和回收都具备确定性，不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟着回收了。而java堆和方法区则不一样。</li>
</ol>
<h4 id="对象已死吗"><a href="#对象已死吗" class="headerlink" title="对象已死吗"></a>对象已死吗</h4><h5 id="Java堆回收"><a href="#Java堆回收" class="headerlink" title="Java堆回收"></a>Java堆回收</h5><ol>
<li>主流的java虚拟机里面没有选用引用计数器算法来管理内存，其中最主要的原因是它很难解决对象之间互相循环引用的问题。</li>
<li>通过可达性分析算法来判定对象是否存活着，算法思路：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</li>
<li>可作为GC Roots的对象包括下面几种:<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI引用的对象</li>
</ol>
</li>
<li>java将引用分为强引用、软引用、弱引用、虚引用，引用强度逐渐减弱。</li>
<li>可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。</li>
<li>finalize()方法中对象逃脱死亡命运的最后一次机会。</li>
<li>任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会再次被执行。尽量避免使用它。</li>
</ol></div><p class="readmore"><a href="/2017/10/30/第3章-垃圾收集器与内存分配策略/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/10/30/第2章-Java内存区域与内存溢出异常/">第2章 Java内存区域与内存溢出异常</a></h1><div class="post-meta">2017-10-30</div><div class="post-content"><h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><ol>
<li>字节码解释器工作时通过改变计数器的值来选取下一条需要执行的字节码指令。</li>
<li>每个线程有独立的计数器。</li>
<li>如果正在执行的是Native方法，这个计数器值为空（Undefined)。</li></div><p class="readmore"><a href="/2017/10/30/第2章-Java内存区域与内存溢出异常/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/10/30/第1章-走进Java/">第1章 走进Java</a></h1><div class="post-meta">2017-10-30</div><div class="post-content"><h3 id="java优点"><a href="#java优点" class="headerlink" title="java优点"></a>java优点</h3><ol>
<li>摆脱平台束缚；</li>
<li>提供一个相对安全的内存管理和访问机制，避免了绝大部分的内存泄露和指针越界问题</li>
<li>实现了热点代码监测和运行时编译及优化</li>
<li>有一套完善的应用程序接口，还有无数来自商业机构和开源社区的第三方类库来帮助它实现各种各样的功能</li>
</ol></div><p class="readmore"><a href="/2017/10/30/第1章-走进Java/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/10/30/我的第一篇博客/">我的第一篇博客</a></h1><div class="post-meta">2017-10-30</div><div class="post-content"><p>首先要纪念一下，这是我第一次写博客，这也是我的第一篇博文。我希望以后几年，十几年，几十年都能够坚持写下去，与大家分享生活与工作中一切好的东西！</p></div><p class="readmore"><a href="/2017/10/30/我的第一篇博客/">阅读全文</a></p></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/学习/">学习</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/学习/JVM/">JVM</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/虚拟机/" style="font-size: 15px;">虚拟机</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/深入理解Java虚拟机读书笔记/" style="font-size: 15px;">深入理解Java虚拟机读书笔记</a> <a href="/tags/感想/" style="font-size: 15px;">感想</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/第8章-虚拟机字节码执行引擎/">第8章 虚拟机字节码执行引擎</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/第7章-虚拟机类加载机制/">第7章 虚拟机类加载机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/第6章-类文件结构/">第6章 类文件结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/第5章-调优案例分析与实战/">第5章 调优案例分析与实战</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/第4章-虚拟机性能监控与故障处理工具/">第4章 虚拟机性能监控与故障处理工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/第3章-垃圾收集器与内存分配策略/">第3章 垃圾收集器与内存分配策略</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/第2章-Java内存区域与内存溢出异常/">第2章 Java内存区域与内存溢出异常</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/第1章-走进Java/">第1章 走进Java</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/我的第一篇博客/">我的第一篇博客</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://shalk.github.io/" title="shalk" target="_blank">shalk</a><ul></ul><a href="http://luckylau.tech/" title="luckylau" target="_blank">luckylau</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">WChCh's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>