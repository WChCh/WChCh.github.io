---
title: CAS(Compare and Swap) 原理学习
date: 2017-12-28 17:22:47
tags: [Java,并发]
categories: [技术,学习,Java,并发]
---

最近打算学习CAS的相关原理，所以转载了一下两篇文章：

[浅谈CAS(Compare and Swap) 原理](http://www.cnblogs.com/Leo_wl/p/6899716.html)

[CAS(Compare and Swap)理解](https://www.cnblogs.com/longshiyVip/p/5205689.html)

#### 什么叫CAS（Compare and Swap）?

硬件同步原语！！ 什么蛋疼的名字，一般人很难理解。根据英文全称翻译==比较与交换，这个名字大致还能理解一点,目前先暂且这么理解吧.

<!--more-->

有啥用处？

对于常用多线程编程的人估计知道，对于一般人估计都不曾听说。在jdk5之前,我们知道，在多线程编程的时候，为了保证多个线程对一个对象同时进行访问时,我们需要加同步锁synchronized,保证对象的在使用时的正确性，但是加锁的机制会导致如下几个问题

1.加多线程竞争下，加锁和释放锁会导致较多的上下文切换，引起性能问题。

2.多线程可以导致死锁的问题。

3.多线程持有的锁会导致其他需要此锁的线程挂起。

4……

有更好的办法么？

锁的分类：独占锁（悲观锁），乐观锁

独占锁：synchronized就是一种独占锁，它会导致所有需要此锁的线程挂起，等待锁的释放。

乐观锁：每次不加锁去完成操作，如果因为冲突失败就重试，直到成功。

CAS的机制就相当于这种（非阻塞算法），CAS是由CPU硬件实现，利用JNI来完成CPU指令的操作，所以执行相当快.CAS有三个操作参数：内存地址，期望值，要修改的新值，当期望值和内存当中的值进行比较不相等的时候，表示内存中的值已经被别线程改动过，这时候失败返回，当相等的时候，将内存中的值改为新的值，并返回成功。





#### CAS缺点

CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作

1. ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。

   从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

关于ABA问题参考文档: [http://blog.hesey.NET/2011/09/resolve-aba-by-atomicstampedreference.html](http://blog.hesey.net/2011/09/resolve-aba-by-atomicstampedreference.html)

1. 循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。

1. 只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。
2. 比较花费CPU资源，即使没有任何争用也会做一些无用功。
3. 会增加程序测试的复杂度，稍不注意就会出现问题。

##### 总结

可以用CAS在无锁的情况下实现原子操作，但要明确应用场合，非常简单的操作且又不想引入锁可以考虑使用CAS操作，当想要非阻塞地完成某一操作也可以考虑CAS。不推荐在复杂操作中引入CAS，会使程序可读性变差，且难以测试，同时会出现ABA问题。